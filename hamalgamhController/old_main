// MKR WiFi 1010 (SAMD21) – Brute-force de PWM 24-bit (TCC0/TCC1) por pin mux E/F
// Compila con core "Arduino SAMD (32-bits ARM Cortex-M0+)"
// Conecta un LED/sonda al pin bajo prueba y GND. Mira el Serial a 115200.

#include <Arduino.h>
#include "wiring_private.h"  // g_APinDescription, etc.

static const uint8_t kPinsToProbe[] = {
  // Ajusta esta lista a los pines del header que quieras probar.
  // Incluyo típicos de MKR*; quita los que uses para periféricos externos.
  // D0..D14 (aprox) + algunos analógicos como digitales.
  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,
  A0, A1, A2, A3, A4, A5, A6
};

// --------- Helpers de bajo nivel (SAMD21) ----------
static inline void waitSyncTCC(Tcc* tcc) {
  while (tcc->SYNCBUSY.reg) { }
}

static void setup_gclk_tcc() {
  // Alimenta TCC0/TCC1 con GCLK0 (48 MHz)
  // Habilita el reloj de perifericos
  PM->APBCMASK.reg |= PM_APBCMASK_TCC0 | PM_APBCMASK_TCC1;

  GCLK->CLKCTRL.reg =
      GCLK_CLKCTRL_ID(TCC0_GCLK_ID) |
      GCLK_CLKCTRL_GEN_GCLK0 |
      GCLK_CLKCTRL_CLKEN;
  while (GCLK->STATUS.bit.SYNCBUSY) {}

  GCLK->CLKCTRL.reg =
      GCLK_CLKCTRL_ID(TCC1_GCLK_ID) |
      GCLK_CLKCTRL_GEN_GCLK0 |
      GCLK_CLKCTRL_CLKEN;
  while (GCLK->STATUS.bit.SYNCBUSY) {}
}

static void tcc_common_config(Tcc* tcc, uint32_t per) {
  // Reset
  tcc->CTRLA.bit.SWRST = 1;
  while (tcc->SYNCBUSY.bit.SWRST || tcc->CTRLA.bit.SWRST) {}

  // Prescaler 1, onda NPWM
  tcc->CTRLA.reg = TCC_CTRLA_PRESCALER_DIV1;
  tcc->WAVE.reg = TCC_WAVE_WAVEGEN_NPWM;
  waitSyncTCC(tcc);

  // Periodo 24-bit (valor > 16 bits para verificar)
  tcc->PER.reg = per;
  waitSyncTCC(tcc);

  // CCx = 50%
  for (int ch = 0; ch < 4; ++ch) {
    if (ch < 2 || tcc == TCC0) { // TCC1 solo tiene CC0..1
      tcc->CC[ch].reg = per / 2;
    }
  }
  waitSyncTCC(tcc);

  // Enable
  tcc->CTRLA.bit.ENABLE = 1;
  waitSyncTCC(tcc);
}

static void tcc_set_duty_both(uint32_t per, float duty01) {
  uint32_t cc = (uint32_t)(per * duty01 + 0.5f);
  // TCC0: CC0..3
  for (int ch = 0; ch < 4; ++ch) {
    TCC0->CC[ch].reg = cc; 
  }
  waitSyncTCC(TCC0);

  // TCC1: CC0..1
  for (int ch = 0; ch < 2; ++ch) {
    TCC1->CC[ch].reg = cc;
  }
  waitSyncTCC(TCC1);
}

static void set_pin_mux(uint8_t pin, uint8_t func /*0..7 = A..H*/) {
  // Deshabilita control GPIO y selecciona periférico func (A..H).
  uint8_t port = g_APinDescription[pin].ulPort;
  uint8_t pinNum = g_APinDescription[pin].ulPin;

  // Habilitar PMUX en el pin
  PORT->Group[port].PINCFG[pinNum].bit.PMUXEN = 1;

  // PMUX es por pares: E/O
  uint8_t pmuxIndex = pinNum >> 1;
  bool odd = pinNum & 1;

  if (odd) {
    // PMUXO
    uint8_t val = PORT->Group[port].PMUX[pmuxIndex].bit.PMUXE;
    PORT->Group[port].PMUX[pmuxIndex].reg = (val & 0x0F) | (func << 4);
  } else {
    // PMUXE
    uint8_t val = PORT->Group[port].PMUX[pmuxIndex].bit.PMUXO;
    PORT->Group[port].PMUX[pmuxIndex].reg = (val << 4) | (func & 0x0F);
  }
}

static void release_pin_to_gpio(uint8_t pin) {
  // Vuelve a control GPIO como entrada con pull-down (silencio)
  pinMode(pin, INPUT_PULLDOWN);
  uint8_t port = g_APinDescription[pin].ulPort;
  uint8_t pinNum = g_APinDescription[pin].ulPin;
  PORT->Group[port].PINCFG[pinNum].bit.PMUXEN = 0; // quita periférico
}

// ----------------------------------------------------

const uint32_t PER_24 = 100000; // > 16 bits; ~480 Hz con prescaler 1

void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 4000) {}

  Serial.println();
  Serial.println(F("=== MKR1010: brute-force PWM 24-bit (TCC0/TCC1) por pin mux E/F ==="));
  Serial.println(F("Frecuencia ~480 Hz, PER=100000 (>16 bits). Buscando pines con WO[x]."));
  Serial.println(F("Conecta sonda/LED al pin anunciado. Se alterna duty 25%/75% para que se note."));
  Serial.println();

  // Inicializa TCC0/TCC1
  setup_gclk_tcc();
  tcc_common_config(TCC0, PER_24);
  tcc_common_config(TCC1, PER_24);

  // Todos los pines a estado seguro
  for (uint8_t p : kPinsToProbe) {
    release_pin_to_gpio(p);
  }
}

void loop() {
  // Recorre pines y prueba MUX E (func=4) y MUX F (func=5)
  const uint8_t funcs[2] = { 4, 5 }; // E=4, F=5
  const char* fname[2] = { "E", "F" };

  for (uint8_t p : kPinsToProbe) {
    for (int fi = 0; fi < 2; ++fi) {
      // Conectar pin al periférico
      set_pin_mux(p, funcs[fi]);
      delay(10); // pequeño settle

      Serial.print(F("[TEST] Pin "));
      Serial.print(p);
      Serial.print(F(" -> MUX "));
      Serial.print(fname[fi]);
      Serial.println(F(" (busca 480 Hz con duty alternando)"));

      // Alterna duty para que sea obvio (25% por 400 ms, 75% por 400 ms)
      tcc_set_duty_both(PER_24, 0.25f);
      delay(400);
      tcc_set_duty_both(PER_24, 0.75f);
      delay(400);

      // Libera pin antes de pasar al siguiente MUX/pin
      release_pin_to_gpio(p);
      delay(20);
    }
  }

  Serial.println(F("Ciclo completo. Repitiendo..."));
}
